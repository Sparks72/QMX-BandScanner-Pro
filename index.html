

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.5, maximum-scale=3.0, user-scalable=yes">
    <title>QMX BandScanner Pro (Enhanced Layout)</title>
    <style>
        :root {
            --bg-color: #0d1117;
            --panel-bg: #161b22;
            --text-color: #e6edf3;
            --accent-color: #2f81f7;
            --signal-color: #3fb950;
            --danger-color: #f85149;
            --border-color: #30363d;
            --lcd-bg: #000000;
            --lcd-text: #00ff00;
            --section-bg: #1c2128;
        }


/* --- RESPONSIVE ZOOM & SCALING --- */
html {
    /* Allow pinch-to-zoom on touch devices */
    touch-action: manipulation;
}

/* Ensure all containers can shrink if needed */
* {
    min-width: 0;
    min-height: 0;
}

/* Media query for smaller screens */
@media (max-width: 768px) {
    body {
        padding: 10px;
        font-size: 14px;
    }
    
    .freq-readout {
        font-size: 3rem !important; /* Smaller on mobile */
    }
    
    .header-section {
        grid-template-columns: 1fr; /* Stack vertically on mobile */
    }
    
    .system-box {
        min-width: unset;
    }
    
    .ctrl-btn {
        padding: 6px 10px;
        font-size: 0.8rem;
    }
}

@media (max-width: 480px) {
    .freq-readout {
        font-size: 2rem !important; /* Even smaller on tiny screens */
    }
    
    .tuning-knob-container {
        width: 80px !important;
        height: 80px !important;
    }
}
body {
    background-color: var(--bg-color);
    color: var(--text-color);
    font-family: 'Segoe UI', 'Roboto', monospace;
    margin: 0;
    padding: 15px;
    display: flex;
    flex-direction: column;
    min-height: 100vh; /* Changed from height to min-height */
    box-sizing: border-box;
    overflow-y: auto; /* Changed from hidden to auto */
    overflow-x: hidden; /* Prevent horizontal scroll */
    cursor: default;
}

        /* --- TOOLTIP BUBBLE --- */
        #uiTooltip {
            position: absolute;
            background: rgba(13, 17, 23, 0.95);
            border: 1px solid var(--accent-color);
            color: #fff;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 9999;
            white-space: nowrap;
            box-shadow: 0 4px 15px rgba(0,0,0,0.8);
            backdrop-filter: blur(4px);
        }

        /* --- MAIN LAYOUT --- */
        .header-section {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 15px;
            margin-bottom: 15px;
            flex-shrink: 0;
        }

        /* --- VFO --- */
        .vfo-container {
            background: var(--lcd-bg);
            border: 2px solid #333;
            border-radius: 8px;
            padding: 15px 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.1);
            gap: 30px;
        }
        .freq-wrapper {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .freq-readout {
            font-family: 'Courier New', monospace;
            font-size: 4.5rem;
            font-weight: bold;
            color: var(--lcd-text);
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            letter-spacing: 3px;
            line-height: 1;
        }
        .vfo-label {
            font-size: 0.85em;
            color: #555;
            letter-spacing: 2px;
        }
        .vfo-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .ctrl-btn {
            background: #21262d;
            border: 1px solid #30363d;
            color: #c9d1d9;
            padding: 8px 14px;
            border-radius: 4px;
            font-size: 0.9rem;
            cursor: pointer;
            font-family: monospace;
            min-width: 55px;
            transition: all 0.1s;
            font-weight: 500;
        }
        .ctrl-btn:hover {
            background: #30363d;
            color: white;
            transform: translateY(-1px);
        }
        .mode-btn.active {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
            box-shadow: 0 0 8px rgba(47, 129, 247, 0.4);
        }
        .db-mini {
            font-family: 'Courier New', monospace;
            font-size: 1.4rem;
            color: var(--accent-color);
            text-align: center;
            padding: 5px 10px;
            background: rgba(47, 129, 247, 0.1);
            border-radius: 4px;
            min-width: 100px;
        }
		
		
		
		/* --- TUNING DIAL --- */
.tuning-dial-container {
    display: none; /* Hidden by default */
    flex-direction: column;
    align-items: center;
    gap: 5px;
}
.tuning-dial-container.active {
    display: flex;
}
.tuning-knob-container { 
    width: 120px; 
    height: 120px; 
    position: relative; 
    cursor: grab; 
}
.tuning-knob {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background: linear-gradient(135deg, #f5f5f5, #e0e0e0, #c0c0c0, #a0a0a0);
    position: relative;
    cursor: pointer;
    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4), inset 0 4px 6px rgba(255, 255, 255, 0.8), inset 0 -4px 6px rgba(0, 0, 0, 0.3);
    transform: rotate(0deg);
    border: 2px solid #888;
    background-image:
        repeating-conic-gradient(rgba(255, 255, 255, 0.15) 0deg, rgba(0, 0, 0, 0.1) 5deg, rgba(255, 255, 255, 0.15) 10deg),
        repeating-radial-gradient(circle at 50% 50%, #c0c0c0 0%, #d0d0d0 2%, #c0c0c0 4%),
        linear-gradient(135deg, #f0f0f0, #c0c0c0, #a0a0a0);
    background-size: 100% 100%, 30% 30%, 100% 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    transition: box-shadow 0.2s;
}
.tuning-knob::before {
    content: "";
    position: absolute;
    width: 0;
    height: 0;
    border-left: 2px solid transparent;
    border-right: 2px solid transparent;
    border-bottom: 6px solid #333;
    top: 8px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 4;
}
.tuning-knob::after {
    content: "";
    position: absolute;
    width: 3px !important;
    height: 45px;
    background: linear-gradient(to top, #333 0%, #333 85%, transparent 85%, transparent 100%) !important;
    top: 12px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 3;
    transition: background-color 0.2s ease;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
}
.tuning-knob-center {
    width: 35px;
    height: 35px;
    border-radius: 50%;
    background: linear-gradient(135deg, #888, #666);
    box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.5);
    position: relative;
    z-index: 2;
}
.tuning-knob:hover::after {
    background: linear-gradient(to top, #00ff88 0%, #00ff88 85%, transparent 85%, transparent 100%) !important;
}
.tuning-knob:hover {
    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4), inset 0 4px 6px rgba(255, 255, 255, 0.8), inset 0 -4px 6px rgba(0, 0, 0, 0.3), 0 0 20px rgba(0, 255, 136, 0.6);
}
.frequency-markings { 
    position: absolute; 
    width: 140px; 
    height: 140px; 
    top: 50%; 
    left: 50%; 
    transform: translate(-50%, -50%); 
    pointer-events: none; 
    z-index: 0; 
}
.frequency-mark {
    position: absolute;
    background: #666;
    width: 1px;
    height: 8px;
    transform-origin: center;
}
.frequency-mark.major {
    width: 2px;
    height: 12px;
    background: #888;
}
.tuning-label {
    font-size: 0.7em;
    color: #555;
    letter-spacing: 1px;
    text-align: center;
}
		

        /* --- SYSTEM CONTROLS BOX --- */
        .system-box {
            background: var(--section-bg);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-width: 200px;
        }
        .system-box h3 {
            margin: 0 0 5px 0;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #8b949e;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
        }

        /* --- CONTROLS PANEL --- */
        .controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            background: var(--panel-bg);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            margin-bottom: 15px;
            flex-shrink: 0;
        }
        
        .control-section {
            background: var(--section-bg);
            padding: 15px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .section-title {
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--accent-color);
            font-weight: 600;
            margin: 0 0 8px 0;
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 6px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        label {
            font-size: 0.75em;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #8b949e;
            font-weight: 500;
        }
        
        select, button.main-btn, input[type=number] {
            background: #21262d;
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 10px 12px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        select:hover, input[type=number]:hover {
            border-color: var(--accent-color);
            background: #2a2f38;
        }
        
        button.main-btn {
            background: var(--accent-color);
            color: white;
            font-weight: bold;
            cursor: pointer;
            padding: 12px 16px;
            font-size: 15px;
            transition: all 0.2s;
        }
        button.main-btn:hover:not(:disabled) {
            background: #4a94ff;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(47, 129, 247, 0.3);
        }
        button.main-btn:disabled {
            background: #30363d;
            opacity: 0.5;
            cursor: not-allowed;
        }
        button.main-btn.active-toggle {
            background: #d29922;
        }
        button.main-btn.active-toggle:hover:not(:disabled) {
            background: #e5a930;
        }
        button.stop-btn {
            background: var(--danger-color);
        }
        button.stop-btn:hover:not(:disabled) {
            background: #ff6b6b;
        }

        /* SLIDERS */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
            cursor: pointer;
            height: 30px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: var(--text-color);
            border: 3px solid var(--accent-color);
            margin-top: -7px;
            position: relative;
            z-index: 10;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        input[type=range]::-webkit-slider-thumb:hover {
            background: white;
            border-color: #4a94ff;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            background: #30363d;
            border-radius: 3px;
        }
        .range-wrapper {
            position: relative;
            height: 45px;
            padding-top: 18px;
        }
        .range-wrapper input[type=range] {
            position: absolute;
            pointer-events: none;
            left: 0;
        }
        .range-wrapper input[type=range]::-webkit-slider-thumb {
            pointer-events: auto;
        }

        /* --- STAT DISPLAYS --- */
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(47, 129, 247, 0.05);
            border-radius: 4px;
            border-left: 3px solid var(--accent-color);
        }
        .stat-label {
            font-size: 0.75em;
            color: #8b949e;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .stat-val {
            color: var(--text-color);
            font-weight: bold;
            font-family: monospace;
            font-size: 0.95em;
        }

      /* Add or modify these styles: */

.viz-container {
       flex: 1 1 auto; /* Allow it to grow and shrink */
   
    overflow: visible; /* Don't cut off content */
	
	flex-grow: 1;
    display: flex;
    flex-direction: column;
    gap: 0px !important;      /* Force it with !important */
    min-height: 300px;
    position: relative;
    background: #000;
    border: 2px solid var(--border-color);
    border-radius: 8px;
    padding: 0px;              /* Remove all padding */
   /* overflow: hidden;*/
    box-shadow: inset 0 2px 8px rgba(0,0,0,0.5);
}

canvas {
    width: 100%;
    flex-shrink: 0;
    image-rendering: pixelated;
    display: block !important;  /* Force block display */
    margin: 0 !important;       /* Force no margin */
    padding: 0 !important;      /* Force no padding */
    line-height: 0;             /* Remove line height gap */
}

#spectrumCanvas {
    height: 80px;
    background: #000;
    margin: 0 !important;
    padding: 0 !important;
}

#waterfallCanvas {
    flex-grow: 1;
    min-height: 150px;
    background: #000;
    margin: 0 !important;       /* Force no margin */
    padding: 0 !important;
}

#audioCanvas {
    height: 35px;
    background: #161b22;
    margin-top: 0px !important; /* Was 4px - remove it */
    border-radius: 4px;
}
     /*   }
        #waterfallCanvas {
            flex-grow: 1;
            min-height: 150px;
            background: #000;
        }
        #audioCanvas {
            height: 35px;
            background: #161b22;
            margin-top: 4px;
            border-radius: 4px;
        }

        .status-bar {
            margin-top: 10px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            font-size: 0.85em;
        }

        /* Button groups */
        .btn-row {
            display: flex;
            gap: 8px;
        }
        .btn-row button {
            flex: 1;
        }

        /* Volume control styling */
        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: rgba(47, 129, 247, 0.05);
            border-radius: 4px;
        }
        .volume-control span {
            font-size: 0.8em;
            color: #8b949e;
            min-width: 35px;
        }
        .volume-control input[type=range] {
            flex: 1;
        }
        .volume-control input[type=range]:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
		
		
		</style>
</head>
<body>

    <div id="uiTooltip"></div>

    <!-- HEADER SECTION -->
    <div class="header-section">
        <!-- VFO Display -->
        <div class="vfo-container">
            <div class="freq-wrapper">
                <div id="freqDisplay" class="freq-readout" data-title="Current QMX VFO A Frequency">--.---.---</div>
                <div class="vfo-label">QMX PROFESSIONAL BAND SCANNER</div>
            </div>
			
			<!-- TUNING DIAL (Hidden by default, shown when stopped) -->
<div class="tuning-dial-container" id="tuningDialContainer">
    <div class="tuning-knob-container" id="tuningKnobContainer">
        <div class="frequency-markings" id="frequencyMarkings"></div>
        <div class="tuning-knob" id="tuningKnob" tabindex="0">
            <div class="tuning-knob-center"></div>
        </div>
    </div>
    <div class="tuning-label">FINE TUNE</div>
</div>
			
			
			
            <div class="vfo-controls">
                <div style="display:flex; gap:6px;">
                    <button class="ctrl-btn mode-btn" onclick="setMode('LSB', 1)" data-title="Set Mode: Lower Sideband">LSB</button>
                    <button class="ctrl-btn mode-btn" onclick="setMode('USB', 2)" data-title="Set Mode: Upper Sideband">USB</button>
                    <button class="ctrl-btn mode-btn" onclick="setMode('CW', 3)" data-title="Set Mode: Continuous Wave">CW</button>
                    <button class="ctrl-btn mode-btn" onclick="setMode('DIG', 6)" data-title="Set Mode: Digital / Data">DIG</button>
                </div>
                <div style="display:flex; gap:6px;">
                    <button class="ctrl-btn" onclick="tuneStep(-100)" data-title="Tune Down 100Hz">-100</button>
                    <button class="ctrl-btn" onclick="tuneStep(-10)" data-title="Tune Down 10Hz">-10</button>
                    <button class="ctrl-btn" onclick="tuneStep(10)" data-title="Tune Up 10Hz">+10</button>
                    <button class="ctrl-btn" onclick="tuneStep(100)" data-title="Tune Up 100Hz">+100</button>
                </div>
                <div id="dbDisplay" class="db-mini" data-title="Live Signal Strength (dBm)">-- dB</div>
            </div>
        </div>

        <!-- System Controls -->
        <div class="system-box">
            <h3>System <span style="font-size:0.7em; color:#8b949e; font-weight:normal; margin-left:8px;">(115200 baud)</span></h3>
            <button id="btnConnect" class="main-btn" data-title="Open Serial Port Connection to Radio">Connect Radio</button>
            <button id="btnAudio" class="main-btn" data-title="Enable Browser Audio (Speakers)">Enable Audio</button>
            <div class="volume-control">
                <span>Vol</span>
                <input type="range" id="volSlider" min="0" max="500" value="100" disabled data-title="Digital Audio Boost (100% = Normal, 500% = Boost)">
            </div>
			
			<div class="volume-control" style="margin-top:5px; border-left: 3px solid #d29922;">
    <span>DSP</span>
    <input type="range" id="dspSlider" min="1" max="20" value="1" disabled data-title="Software Pre-Amp Boost (Multiplier x1 to x20)">
</div>
        </div>
    </div>

    <!-- CONTROLS PANEL -->
    <div class="controls">
        <!-- Band Selection -->
        <div class="control-section">
            <h3 class="section-title">Band Selection</h3>
            <div class="control-group">
                <label>Amateur Band</label>
                <select id="bandSelect" data-title="Choose HF Amateur Radio Band">
                    <option value="1800000,2000000">160m (1.8-2.0 MHz)</option>
					<option value="3500000,4000000">80m (3.5-4.0 MHz)</option>
					<option value="5351500,5366500">60m (5.3515-5.3665 MHz)</option>
					<option value="7000000,7300000" selected>40m (7.0-7.3 MHz)</option>
                    <option value="10100000,10150000">30m (10.1-10.15 MHz)</option>
                    <option value="14000000,14350000">20m (14.0-14.35 MHz)</option>
                    <option value="18068000,18168000">17m (18.068-18.168 MHz)</option>
                    <option value="21000000,21450000">15m (21.0-21.45 MHz)</option>
                    <option value="24890000,24990000">12m (24.89-24.99 MHz)</option>
                    <option value="28000000,29700000">10m (28.0-29.7 MHz)</option>
				<!--	<option value="050000,30000000">Gen (500khz-30.0 MHz)</option> -->
                </select>
            </div>

            <div class="control-group">
                <label>Scan Resolution</label>
                <select id="stepSelect" data-title="Frequency Step Between Scan Points">
                    <option value="100" selected>0.1 kHz (Very Fine)</option>
                    <option value="250">0.25 kHz (Fine)</option>
                    <option value="500">0.5 kHz (Medium)</option>
                    <option value="1000">1 kHz (Fast)</option>
                    <option value="2500">2.5 kHz (Very Fast)</option>
                </select>
            </div>
        </div>

        <!-- Scan Control -->
        <div class="control-section">
            <h3 class="section-title">Scanner Control</h3>
            <div class="control-group">
                <button id="btnScan" class="main-btn" disabled data-title="Begin Band Scan">Start Scan</button>
                <button id="btnStop" class="main-btn stop-btn" disabled data-title="Stop Current Scan">Stop Scan</button>
            </div>

            <div class="control-group">
                <label>Slice Range (% of band)</label>
                <div class="range-wrapper">
                    <input type="range" id="startSlider" min="0" max="100" value="0" data-title="Set Start of Scan Slice">
                    <input type="range" id="endSlider" min="0" max="100" value="100" style="margin-top:15px;" data-title="Set End of Scan Slice">
                </div>
            </div>

            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:8px; margin-top:10px;">
                <div class="stat-row">
                    <span class="stat-label">Start</span>
                    <span id="txtStart" class="stat-val">--.---</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">End</span>
                    <span id="txtEnd" class="stat-val">--.---</span>
                </div>
            </div>
        </div>

        <!-- Display Settings -->
        <div class="control-section">
            <h3 class="section-title">Display Settings</h3>
            <div class="control-group">
                <label>Spectrum Peak Hold</label>
                <input type="number" id="peakHold" value="20" min="0" max="100" data-title="Frames to Hold Peak Values">
            </div>

            <div class="control-group">
                <label>Waterfall Floor</label>
                <div style="display:flex; gap:8px; align-items:center;">
                    <input type="range" id="wfFloorSlider" min="-140" max="-90" value="-130" style="flex:1;" data-title="Noise Floor Threshold - adjust until noise is dark blue">
                    <span id="wfFloorLabel" style="font-size:0.85em; min-width:50px;">-130 dB</span>
                </div>
            </div>

            <div class="control-group">
                <label>Waterfall Gain</label>
                <div style="display:flex; gap:8px; align-items:center;">
                    <input type="range" id="wfGainSlider" min="0.5" max="8" value="1" step="0.1" style="flex:1;" data-title="Signal Contrast - increase to make weak signals more visible">
                    <span id="wfGainLabel" style="font-size:0.85em; min-width:50px;">1.0</span>
                </div>
            </div>
        </div>
    </div>

    <!-- VISUALIZATION -->
    <div class="viz-container">
        <canvas id="spectrumCanvas" width="800" height="140"></canvas>
        <canvas id="waterfallCanvas" width="800" height="150"></canvas>
        <canvas id="audioCanvas" width="800" height="35"></canvas>
    </div>

    <!-- STATUS BAR -->
    <div class="status-bar">
        <div class="stat-row">
            <span class="stat-label">Resolution</span>
            <span id="lblRes" class="stat-val">1000Hz</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Slice Width</span>
            <span id="lblWidth" class="stat-val">0.0kHz</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Scan Speed</span>
            <span id="lblScanSpeed" class="stat-val">0 pts/s</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Status</span>
            <span id="lblStatus" class="stat-val">Ready</span>
        </div>
        <div style="display:flex; gap:10px; align-items:center; padding:8px 12px; background: rgba(47, 129, 247, 0.05); border-radius: 4px; border-left: 3px solid var(--accent-color);">
            <span class="stat-label" style="min-width:45px;">Dwell:</span>
            <input type="range" id="dwellSlider" min="0" max="100" value="5" step="1" style="width:120px;" data-title="Loop delay per frequency step. Decrease until error rate appears in status. Optimal: ~5ms at 115200 baud, ~10ms at 38400 baud">
            <span id="dwellLabel" style="font-size:0.85em; min-width:40px; font-family: monospace; font-weight: bold; color: var(--accent-color);">5ms</span>
            <span style="font-size:0.7em; color: #8b949e; margin-left: 5px;">(0-100ms)</span>
        </div>
    </div>

<script>
    
	
	const CONFIG = { baudRate: 115200 };
	const TUNING_STEP = 10;
    const state = {
        port: null, isConnected: false, isScanning: false, scanPaused: false, portBusy: false,
        currentVfoFreq: 14000000, currentMode: 2,
       fullBandMin: 7000000, fullBandMax: 7300000,
       activeStart: 7000000, activeEnd: 7300000,
       step: 100,
       dwellTime: 3,
        scanData: [], currentIndex: 0,passOffset: 0,      // Tracks which "interlace" pass we are on
        scanStride: 4, lastScanTime: 0,
        
        audioContext: null, gainNode: null, audioAnalyser: null,
       wfFloor: -130, wfGain: 1,
        peakHold: 20, peakData: [], palette: [],
        timeoutCount: 0, successCount: 0,
		// Tuning dial state
     tuningKnobRotation: 0,
    tuningLastAngle: 0,
    isTuningAdjusting: false,
    tuningAnimationFrame: null,
	currentFreq: 14000000, 
    isHoveringTuningKnob: false,
    };
  const els = {
        freqDisplay: document.getElementById('freqDisplay'),
        dbDisplay: document.getElementById('dbDisplay'),
        bandSelect: document.getElementById('bandSelect'),
        stepSelect: document.getElementById('stepSelect'),
        btnConnect: document.getElementById('btnConnect'),
        btnAudio: document.getElementById('btnAudio'),
        btnScan: document.getElementById('btnScan'),
        btnStop: document.getElementById('btnStop'),
        volSlider: document.getElementById('volSlider'),
        dspSlider: document.getElementById('dspSlider'), // Ensure DSP slider is here
        startSlider: document.getElementById('startSlider'),
        endSlider: document.getElementById('endSlider'),
        txtStart: document.getElementById('txtStart'),
        txtEnd: document.getElementById('txtEnd'),
        lblRes: document.getElementById('lblRes'),
        lblWidth: document.getElementById('lblWidth'),
        lblScanSpeed: document.getElementById('lblScanSpeed'),
        lblStatus: document.getElementById('lblStatus'),
        
        // These are the ones causing your error:
        wfFloorSlider: document.getElementById('wfFloorSlider'),
        wfFloorLabel: document.getElementById('wfFloorLabel'),
        wfGainSlider: document.getElementById('wfGainSlider'),
        wfGainLabel: document.getElementById('wfGainLabel'),
        
        dwellSlider: document.getElementById('dwellSlider'),
        dwellLabel: document.getElementById('dwellLabel'),
        spectrum: document.getElementById('spectrumCanvas'),
        waterfall: document.getElementById('waterfallCanvas'),
        audio: document.getElementById('audioCanvas'),
        tuningDialContainer: document.getElementById('tuningDialContainer'),
        tuningKnob: document.getElementById('tuningKnob')
    };
    // Init palette (Blue→Green→Yellow→Red)
    for (let i = 0; i < 256; i++) {
        const t = i / 255;
        let r, g, b;
        if (t < 0.25) {
            r = 0; g = Math.floor(t * 4 * 255); b = 255;
        } else if (t < 0.5) {
            const t2 = (t - 0.25) * 4; r = 0; g = 255; b = Math.floor((1 - t2) * 255);
        } else if (t < 0.75) {
            const t2 = (t - 0.5) * 4; r = Math.floor(t2 * 255); g = 255; b = 0;
        } else {
            const t2 = (t - 0.75) * 4; r = 255; g = Math.floor((1 - t2) * 255); b = 0;
        }
        state.palette.push(r, g, b, 255);
    }

    // Tooltips
    const tooltip = document.getElementById('uiTooltip');
    document.querySelectorAll('[data-title]').forEach(el => {
        el.addEventListener('mouseenter', e => {
            const title = el.getAttribute('data-title');
            if (!title) return;
            tooltip.textContent = title;
            tooltip.style.display = 'block';
            const rect = el.getBoundingClientRect();
            tooltip.style.left = rect.left + 'px';
            tooltip.style.top = (rect.bottom + 5) + 'px';
        });
        el.addEventListener('mouseleave', () => { tooltip.style.display = 'none'; });
    });

    // Mode buttons
    document.querySelectorAll('.mode-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        });
    });

    // Serial/CAT
    async function sendCommand(cmd, expectResponse = true) {
        if (!state.port || state.portBusy) return null;
        let writer = null, reader = null;
        try {
            state.portBusy = true;
            let payload = cmd.trim();
            if (!payload.endsWith(';')) payload += ';';
            const encoder = new TextEncoder();
            writer = state.port.writable.getWriter();
            await writer.write(encoder.encode(payload));
            writer.releaseLock();
            writer = null;

            if (!expectResponse) {
                state.portBusy = false;
                return "OK";
            }

            reader = state.port.readable.getReader();
            const decoder = new TextDecoder();
            let fullResponse = "";
            
            const readPromise = async () => {
                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    if (value) {
                        fullResponse += decoder.decode(value);
                        if (fullResponse.includes(';')) break;
                    }
                }
                return fullResponse;
            };
            const result = await Promise.race([
                readPromise(),
                new Promise(r => setTimeout(() => r("TIMEOUT"), 1))
            ]);

            if (result === "TIMEOUT") {
                try { await reader.cancel(); } catch(e) {}
                return null;
            }
            return result.trim();
        } catch (e) {
            console.error(e);
            return null;
        } finally {
            if (writer) try { writer.releaseLock(); } catch(e) {}
            if (reader) try { reader.releaseLock(); } catch(e) {}
            state.portBusy = false;
        }
    }

    async function runTask(task) {
        if (!state.isConnected) return;
        state.scanPaused = true;
        let r = 0;
        while (state.portBusy && r++ < 20) await new Promise(x => setTimeout(x, 10));
        try {
            await task();
        } finally {
            state.scanPaused = false;
        }
    }

    function processResponse(rawText) {
        if (!rawText) return null;
        const parts = rawText.split(';').filter(p => p.trim().length > 0);
        let smValue = null;
        parts.forEach(cmd => {
            cmd = cmd.trim();
            if (cmd.startsWith('SM')) {
                const val = parseInt(cmd.substring(2));
                if (!isNaN(val)) smValue = val;
            } else if (cmd.startsWith('MD')) {
                const modeCode = cmd.substring(2);
                const map = { '1': 'LSB', '2': 'USB', '3': 'CW', '6': 'DIG' };
                const name = map[modeCode];
                if (name) {
                    document.querySelectorAll('.mode-btn').forEach(b => {
                        b.classList.toggle('active', b.innerText === name);
                    });
                }
            } else if (cmd.startsWith('FA')) {
                const f = parseInt(cmd.substring(2));
                if (!isNaN(f)) {
                    state.currentVfoFreq = f;
                    updateBigDisplay(f, "--");
                }
            }
        });
        return smValue;
    }

    async function setMode(mode, modeNum) {
        if (!state.isConnected) return;
        state.currentMode = modeNum;
        await runTask(async () => { await sendCommand(`MD${modeNum}`, true); });
    }

    async function tuneStep(hz) {
        if (!state.isConnected) return;
        if (state.isScanning) stopScanner();
        await runTask(async () => {
            state.currentVfoFreq += hz;
            state.currentFreq = state.currentVfoFreq;  // Keep in sync
            const freqStr = state.currentVfoFreq.toString().padStart(11, '0');
            await sendCommand(`FA${freqStr}`, true);
            updateBigDisplay(state.currentVfoFreq, "--");
        });
    }

  async function scanLoop() {
    if (!state.isScanning) return;
    if (state.scanPaused) {
        setTimeout(scanLoop, 50);
        return;
    }

    // 1. Check if we reached the end of the band for this pass
    if (state.currentIndex >= state.scanData.length) {
        
        // DRAW FAST: Update the waterfall now!
        drawWaterfall(); 
        
        // Speed Calculation
        const now = Date.now();
        const dur = (now - state.lastScanTime) / 1000;
        if (dur > 0) {
            const pointsScanned = Math.ceil(state.scanData.length / state.scanStride);
            els.lblScanSpeed.innerText = Math.round(pointsScanned / dur) + " upd/s";
        }
        state.lastScanTime = now;

        // INTERLACING LOGIC
        state.passOffset++;
        if (state.passOffset >= state.scanStride) {
            state.passOffset = 0;
        }
        
        state.currentIndex = state.passOffset;
    }

    // 2. Prepare the frequency
    const freq = state.activeStart + (state.currentIndex * state.step);
    
    // Safety check for band limits
    if (freq > state.activeEnd) {
         state.currentIndex = state.scanData.length + 1; 
         scanLoop(); 
         return;
    }

    const freqStr = freq.toString().padStart(11, '0');
    
    // 3. Send Command
    const rawData = await sendCommand(`FA${freqStr};SM`, true);
     console.log('Freq:',freqStr);
    // 4. Process Data
    if (!rawData) {
        state.timeoutCount++;
        setTimeout(scanLoop, 10);
        return;
    }

    state.successCount++;
    let smValue = processResponse(rawData);
    
    if (smValue !== null) {
        let dispDb = (smValue / 2) - 130;
        state.scanData[state.currentIndex] = dispDb;
        
        // Update the main display
        updateBigDisplay(freq, Math.round(dispDb)); 
    }

    // 5. Increment by STRIDE
    state.currentIndex += state.scanStride;

    // 6. Fast Loop
    if (state.isScanning) {
        if (state.dwellTime < 2) {
            scanLoop();
        } else {
            setTimeout(scanLoop, state.dwellTime);
        }
    }
}


 // ==========================================
    // ===== FIXED VISUALIZATION & RENDER LOOP =====
    // ==========================================

   function drawSpectrum() {
        const cvs = els.spectrum;
        const ctx = cvs.getContext('2d');
        const w = cvs.width;
        const h = cvs.height;

        // 1. Clear & Grid
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, w, h);

        ctx.strokeStyle = '#333'; 
        ctx.lineWidth = 1;
        ctx.beginPath();
        // Horizontal grid lines (20%, 40%, 60%, 80%)
        for (let i = 1; i < 5; i++) {
            const y = (i / 5) * h;
            ctx.moveTo(0, y); ctx.lineTo(w, y); 
        }
        // Vertical grid lines
        for (let i = 1; i < 10; i++) {
            const x = (i / 10) * w;
            ctx.moveTo(x, 0); ctx.lineTo(x, h);
        }
        ctx.stroke();

        const len = state.scanData.length;
        if (len === 0) return;

        // 2. Prepare Peak Hold
        if (!state.peakData.length || state.peakData.length !== len) {
            state.peakData = new Array(len).fill(-170); // Reset to new floor
        }
        const hold = parseInt(document.getElementById('peakHold').value) || 0;

        // 3. Draw Signal
        ctx.strokeStyle = '#3fb950'; // Green
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        for (let i = 0; i < len; i++) {
            const x = (i / len) * w;
            let db = state.scanData[i];
            
            // --- CALIBRATION ADJUSTMENT ---
            // Clamp values
            if (db < -170) db = -170;
            if (db > -50) db = -50;

            // Math to Center the Graph:
            // Floor: -170dB (Bottom of screen)
            // Range: 100dB (Top of screen is -70dB)
            // Your noise (-118dB) will be at ~52% height (CENTERED)
            const y = h - ((db + 170) / 100 * h); 

            // Update Peak
            if (hold > 0) {
                if (db > state.peakData[i]) state.peakData[i] = db;
                else state.peakData[i] -= (0.5 / hold); 
                if (state.peakData[i] < -170) state.peakData[i] = -170;
            }

            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();

        // 4. Draw Peak Overlay (Orange)
        if (hold > 0) {
            ctx.strokeStyle = '#ffaa00';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let i = 0; i < len; i++) {
                const x = (i / len) * w;
                let db = state.peakData[i];
                if (db < -170) db = -170;
                
                // Same math for peaks
                const y = h - ((db + 170) / 100 * h);
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }
    }

    function drawWaterfall() {
        const cvs = els.waterfall;
        const ctx = cvs.getContext('2d', { alpha: false });
        const w = cvs.width;
        const h = cvs.height;
        
        if (state.scanData.length === 0 || w === 0 || h === 0) return;

        // 1. Shift existing content down by 1 pixel
        ctx.drawImage(cvs, 0, 0, w, h - 1, 0, 1, w, h - 1);

        // 2. Create the new line scaled to canvas width
        const lineData = ctx.createImageData(w, 1);
        const pixels = lineData.data;
        const len = state.scanData.length;

        for (let x = 0; x < w; x++) {
            // Map canvas x position to scan data index
            const dataIdx = Math.floor(x * len / w);
            
            // Scale: floor is the "black" level, gain controls contrast
            // Typical signal range: -130 (noise) to -70 (strong signal) = 60dB range
            let v = state.scanData[dataIdx] - state.wfFloor;
            if (v < 0) v = 0;
            
            // Map to 0-255 with gain adjustment
            // With gain=1, 60dB range maps to full palette
            // Higher gain = more contrast (smaller range fills palette)
            let idx = Math.floor(v * state.wfGain * 4.25);  // 60dB * 4.25 ≈ 255
            if (idx > 255) idx = 255;
            if (idx < 0) idx = 0;
            
            const pIdx = x * 4;
            pixels[pIdx] = state.palette[idx * 4];
            pixels[pIdx + 1] = state.palette[idx * 4 + 1];
            pixels[pIdx + 2] = state.palette[idx * 4 + 2];
            pixels[pIdx + 3] = 255;
        }

        // 3. Draw synchronously at top row
        ctx.putImageData(lineData, 0, 0);
    }
    function updateBigDisplay(freq, db) {
        const mhz = (freq / 1000000).toFixed(6);
        els.freqDisplay.innerText = mhz;
        if (db !== "--") els.dbDisplay.innerText = db + " dBm";
    }
	
	
	// ===== TUNING DIAL FUNCTIONS =====
function initTuningKnob() {
    createFrequencyMarkings();
    state.tuningKnobRotation = 0;
    els.tuningKnob.style.transform = `rotate(${state.tuningKnobRotation}deg)`;
    
    els.tuningKnob.addEventListener('mousedown', startTuningAdjust);
    els.tuningKnob.addEventListener('touchstart', startTuningAdjust, { passive: false });
    els.tuningKnob.addEventListener('wheel', handleTuningWheel);
    
    // --- CHANGED THIS LINE --- 
    // Listen globally on the document so we don't need to click the knob to focus it
    document.addEventListener('keydown', handleTuningKeyboard); 
    
    els.tuningKnob.addEventListener('mouseenter', enableTuningHoverKeys);
    els.tuningKnob.addEventListener('mouseleave', disableTuningHoverKeys);
}

function createFrequencyMarkings() {
    const markingsContainer = document.getElementById('frequencyMarkings');
    markingsContainer.innerHTML = '';
    for (let i = 0; i < 72; i++) {
        const angle = (i / 72) * 360;
        const isLarge = i % 6 === 0;
        const mark = document.createElement('div');
        mark.className = `frequency-mark ${isLarge ? 'major' : 'minor'}`;
        mark.style.transform = `rotate(${angle}deg) translate(0, -70px)`;
        mark.style.left = '50%';
        mark.style.top = '50%';
        mark.style.marginLeft = isLarge ? '-1px' : '-0.5px';
        mark.style.marginTop = isLarge ? '-6px' : '-4px';
        if (i === 0) {
            mark.style.height = '6px';
            mark.style.marginTop = '3px';
        }
        markingsContainer.appendChild(mark);
    }
}

function startTuningAdjust(e) {
    e.preventDefault();
    state.isTuningAdjusting = true;
    const rect = e.target.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    
    if (e.type === 'mousedown') {
        state.tuningLastAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
        document.addEventListener('mousemove', continueTuningAdjust);
        document.addEventListener('mouseup', stopTuningAdjust);
    } else if (e.type === 'touchstart') {
        const t = e.touches[0];
        state.tuningLastAngle = Math.atan2(t.clientY - centerY, t.clientX - centerX);
        document.addEventListener('touchmove', continueTuningAdjust, { passive: false });
        document.addEventListener('touchend', stopTuningAdjust);
    }
}

function continueTuningAdjust(e) {
    if (!state.isTuningAdjusting) return;
    if (state.tuningAnimationFrame) {
        cancelAnimationFrame(state.tuningAnimationFrame);
    }
    
    state.tuningAnimationFrame = requestAnimationFrame(() => {
        const rect = els.tuningKnob.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        let currentX, currentY;
        
        if (e.type === 'mousemove') {
            currentX = e.clientX;
            currentY = e.clientY;
        } else if (e.type === 'touchmove') {
            e.preventDefault();
            const t = e.touches[0];
            currentX = t.clientX;
            currentY = t.clientY;
        }
        
        const distance = Math.sqrt(Math.pow(currentX - centerX, 2) + Math.pow(currentY - centerY, 2));
        if (distance < rect.width * 2) {
            const currentAngle = Math.atan2(currentY - centerY, currentX - centerX);
            let deltaAngle = currentAngle - state.tuningLastAngle;
            
            // Handle wrapping from -PI to +PI
            if (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
            if (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;
            
            // Convert radians to degrees
            const degrees = deltaAngle * 180 / Math.PI;

            // Update visuals
            state.tuningKnobRotation += degrees;
            els.tuningKnob.style.transform = `rotate(${state.tuningKnobRotation}deg)`;
            
            // --- UPDATED MATH FOR 5Hz STEPS ---
            // 1. Calculate raw change (0.5 is a sensitivity factor)
            let rawChange = degrees * TUNING_STEP * 0.5;
            
            // 2. Only update if the change is significant enough
            if (Math.abs(rawChange) >= 1) {
                // Round to integer to avoid decimal frequencies
                state.currentFreq += Math.round(rawChange);
                
                updateBigDisplay(state.currentFreq);
                sendFrequency(state.currentFreq);
            }

            state.tuningLastAngle = currentAngle;
        }
        state.tuningAnimationFrame = null;
    });
}
function stopTuningAdjust() {
    state.isTuningAdjusting = false;
    if (state.tuningAnimationFrame) {
        cancelAnimationFrame(state.tuningAnimationFrame);
        state.tuningAnimationFrame = null;
    }
    document.removeEventListener('mousemove', continueTuningAdjust);
    document.removeEventListener('mouseup', stopTuningAdjust);
    document.removeEventListener('touchmove', continueTuningAdjust);
    document.removeEventListener('touchend', stopTuningAdjust);
}

function handleTuningWheel(e) {
    e.preventDefault();
    const dir = e.deltaY > 0 ? -1 : 1;
    
    state.currentFreq += (dir * TUNING_STEP); // Uses 5Hz
    
    state.tuningKnobRotation += dir * 2;  
    els.tuningKnob.style.transform = `rotate(${state.tuningKnobRotation}deg)`;
    
    updateBigDisplay(state.currentFreq);
    sendFrequency(state.currentFreq);
}

function handleTuningKeyboard(e) {
    if (!state.isHoveringTuningKnob) return;

    let dir = 0; // Direction: -1 for down, 1 for up

    if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
        dir = -1;
    } else if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
        dir = 1;
    }

    if (dir !== 0) {
        e.preventDefault();
        
        // --- UPDATED FREQUENCY CALCULATION ---
        state.currentFreq += (dir * TUNING_STEP);
        state.currentVfoFreq = state.currentFreq;

        // Rotate knob: 2 degrees per "click" (independent of Hz step size)
        state.tuningKnobRotation += dir * 2; 
        els.tuningKnob.style.transform = `rotate(${state.tuningKnobRotation}deg)`;

        updateBigDisplay(state.currentFreq, "--");
        sendFrequency(state.currentFreq);
    }
}

function enableTuningHoverKeys() {
    state.isHoveringTuningKnob = true;
}

function disableTuningHoverKeys() {
    state.isHoveringTuningKnob = false;
}

function showTuningDial() {
    els.tuningDialContainer.classList.add('active');
}

function hideTuningDial() {
    els.tuningDialContainer.classList.remove('active');
}


async function sendFrequency(freq) {
    if (!state.isConnected) return;
    const freqStr = freq.toString().padStart(11, '0');
    await sendCommand(`FA${freqStr}`, false);  // false = don't wait for response
}
	
	 function updateFrequencyDisplay(freq) {
        const str = String(freq).padStart(9, '0');
        const mhz = str.substring(0, 2);
        const khz = str.substring(2, 5);
        const hz = str.substring(5, 8);
        els.freqDisplay.innerText = `${mhz}.${khz}.${hz}`;
}
function stopScanner() {
    state.isScanning = false;
    state.scanPaused = false;
    els.btnScan.disabled = false;
    els.btnStop.disabled = true;
    els.lblStatus.innerText = "Stopped";
    
    // Calculate the actual current frequency from scan position
    const currentScanFreq = state.activeStart + (state.currentIndex * state.step);
    state.currentFreq = currentScanFreq;  // Use the actual scanned frequency
    state.currentVfoFreq = currentScanFreq;  // Keep them in sync
    
    showTuningDial();
}

    function initScanParams() {
        state.step = parseInt(els.stepSelect.value);
        const span = state.activeEnd - state.activeStart;
        const points = Math.max(1, Math.floor(span / state.step));
        state.scanData = new Array(points).fill(-130);
        state.currentIndex = 0;
        state.lastScanTime = Date.now();
        state.timeoutCount = 0;
        state.successCount = 0;

        if (els.waterfall.clientWidth > 0) {
            els.waterfall.width = els.waterfall.clientWidth;
            els.waterfall.height = els.waterfall.clientHeight > 50 ? els.waterfall.clientHeight : 150;
            els.spectrum.width = els.spectrum.clientWidth;
            els.spectrum.height = els.spectrum.clientHeight > 50 ? els.spectrum.clientHeight : 140;
        }

        els.lblRes.innerText = state.step + "Hz";
        els.lblWidth.innerText = (span / 1000).toFixed(1) + "kHz";
    }

    function handleRangeInput() {
        let sVal = parseInt(els.startSlider.value);
        let eVal = parseInt(els.endSlider.value);
        if (sVal > eVal - 2) {
            sVal = eVal - 2;
            els.startSlider.value = sVal;
        }

       // Adjust canvas width and position based on scan slice
const sPercent = (sVal / 100) * 100;
const ePercent = (eVal / 100) * 100;
const sliceWidth = ePercent - sPercent;
els.spectrum.style.width = sliceWidth + "%";
els.spectrum.style.marginLeft = sPercent + "%";
els.waterfall.style.width = sliceWidth + "%";
els.waterfall.style.marginLeft = sPercent + "%";

        const span = state.fullBandMax - state.fullBandMin;
        state.activeStart = state.fullBandMin + Math.floor(span * (sVal / 100));
        state.activeEnd = state.fullBandMin + Math.floor(span * (eVal / 100));
        state.activeStart = Math.round(state.activeStart / 1000) * 1000;
        state.activeEnd = Math.round(state.activeEnd / 1000) * 1000;

        els.txtStart.innerText = (state.activeStart / 1000000).toFixed(3);
        els.txtEnd.innerText = (state.activeEnd / 1000000).toFixed(3);
        if (state.isScanning) initScanParams();
        else {
            const currentSpan = state.activeEnd - state.activeStart;
            els.lblWidth.innerText = (currentSpan / 1000).toFixed(1) + "kHz";
        }
    }

   async function updateBandLimits() {
        // 1. Parse the new band limits from the dropdown value
        const parts = els.bandSelect.value.split(',');
        state.fullBandMin = parseInt(parts[0]);
        state.fullBandMax = parseInt(parts[1]);
        
        // 2. Reset the sliders to cover the full band
        els.startSlider.value = 0;
        els.endSlider.value = 100;
        
        // 3. Update the internal variables and text displays
        handleRangeInput();

        // 4. --- NEW: COMMAND THE RADIO TO TUNE IMMEDIATELY ---
        if (state.isConnected && !state.isScanning) {
            
            // Sync internal state to the start of the new band
            state.currentVfoFreq = state.fullBandMin;
            state.currentFreq = state.fullBandMin; 

            // Update the screen display
            updateBigDisplay(state.currentVfoFreq, "--");

            // Send the command to the QMX
            const freqStr = state.currentVfoFreq.toString().padStart(11, '0');
           
			await sendCommand(`FA${freqStr}`, false); 
        }
    }

   

// Check if radio supports the selected band
async function validateBand() {
    if (!state.isConnected) return true;
    
    // Test if radio accepts the frequency
    const testFreq = state.fullBandMin;
    const freqStr = testFreq.toString().padStart(11, '0');
    const response = await sendCommand(`FA${freqStr}`, true);
    
    if (!response || response === "TIMEOUT") {
        alert(`Warning: Radio may not support this band (${(testFreq/1000000).toFixed(3)} MHz). Check QMX band modules.`);
        return false;
    }
    return true;
}



   els.bandSelect.addEventListener('change', async () => {
    await updateBandLimits();
    await validateBand(); // Add validation
});
    els.startSlider.addEventListener('input', handleRangeInput);
    els.endSlider.addEventListener('input', handleRangeInput);
    els.wfFloorSlider.addEventListener('input', (e) => {
        state.wfFloor = parseInt(e.target.value);
        els.wfFloorLabel.innerText = state.wfFloor + ' dB';
    });
    els.wfGainSlider.addEventListener('input', (e) => {
        state.wfGain = parseFloat(e.target.value);
        els.wfGainLabel.innerText = state.wfGain.toFixed(1);
    });
    els.dwellSlider.addEventListener('input', (e) => {
        state.dwellTime = parseInt(e.target.value);
        els.dwellLabel.innerText = state.dwellTime + 'ms';
        // Visual feedback: red when aggressive (<5ms), yellow when moderate (5-10ms), green when safe (>10ms)
        if (state.dwellTime < 5) {
            els.dwellLabel.style.color = '#f85149'; // red - aggressive
        } else if (state.dwellTime <= 10) {
            els.dwellLabel.style.color = '#d29922'; // yellow - moderate
        } else {
            els.dwellLabel.style.color = '#3fb950'; // green - safe
        }
    });

els.btnScan.addEventListener('click', () => {
    hideTuningDial();  // ADD THIS LINE
    state.isScanning = true;
    state.scanPaused = false;
    els.btnScan.disabled = true;
    els.btnStop.disabled = false;
    initScanParams();
    scanLoop();
});

    els.btnStop.addEventListener('click', stopScanner);

    els.btnConnect.addEventListener('click', async () => {
        // Toggle connection
        if (state.isConnected) {
            // Disconnect
            if (state.isScanning) stopScanner();
            try {
                if (state.port) {
                    await state.port.close();
                    state.port = null;
                }
                state.isConnected = false;
                state.portBusy = false;
                els.btnConnect.disabled = false;
                els.btnConnect.innerText = "Connect Radio";
                els.btnConnect.classList.remove('active-toggle');
                els.btnScan.disabled = true;
                els.lblStatus.innerText = "Disconnected";
            } catch (e) {
                console.error("Disconnect error:", e);
            }
        } else {
            // Connect
            if (!navigator.serial) return alert("Web Serial API not supported.");
            try {
                state.port = await navigator.serial.requestPort();
                await state.port.open({ baudRate: CONFIG.baudRate });
                state.isConnected = true;
                els.btnConnect.innerText = "Disconnect";
                els.btnConnect.classList.add('active-toggle');
                els.btnScan.disabled = false;
                els.lblStatus.innerText = "Connected";
                await runTask(async () => {
                    await sendCommand("ID", true);
                    const modeRes = await sendCommand("MD;", true);
                    processResponse(modeRes);
                    // Query current VFO frequency to sync state
                    const freqRes = await sendCommand("FA;", true);
                    processResponse(freqRes);
                    // Also sync currentFreq for tuning dial
                    state.currentFreq = state.currentVfoFreq;
                });
            } catch (e) {
                alert("Connection Failed: " + e.message);
            }
        }
    });

  els.spectrum.addEventListener('click', async (e) => {
        if (!state.isConnected) return;
        
        // 1. Calculate Frequency
        const rect = els.spectrum.getBoundingClientRect();
        const ratio = (e.clientX - rect.left) / rect.width;
        const span = state.activeEnd - state.activeStart;
        const targetFreq = state.activeStart + (ratio * span);
        const finalFreq = Math.round(targetFreq / 100) * 100; // Round to nearest 100Hz

        // 2. Stop Scanner & Show Dial
        stopScanner();
        
        // 3. SYNC THE KNOB STATE (This is the fix)
        state.currentVfoFreq = finalFreq;
        state.currentFreq = finalFreq; 
        
        // Optional: Reset visual rotation to 0 degrees for the new frequency
        state.tuningKnobRotation = 0; 
        els.tuningKnob.style.transform = `rotate(0deg)`;

        // 4. Send Command to Radio
        await runTask(async () => {
            const freqStr = state.currentVfoFreq.toString().padStart(11, '0');
            await sendCommand(`FA${freqStr}`, true);
            updateBigDisplay(state.currentVfoFreq, "--");
        });
    });

    els.btnAudio.addEventListener('click', async () => {
        // Toggle audio
        if (state.audioContext && state.audioContext.state !== 'closed') {
            // Disable audio
            try {
                if (state.gainNode) {
                    state.gainNode.disconnect();
                    state.gainNode = null;
                }
                if (state.audioAnalyser) {
                    state.audioAnalyser.disconnect();
                    state.audioAnalyser = null;
                }
                if (state.audioContext) {
                    await state.audioContext.close();
                    state.audioContext = null;
                }
                els.btnAudio.disabled = false;
                els.btnAudio.innerText = "Enable Audio";
                els.btnAudio.classList.remove('active-toggle');
                els.volSlider.disabled = true;
				els.dspSlider.disabled = true;
                els.lblStatus.innerText = state.isConnected ? "Connected" : "Ready";
            } catch (e) {
                console.error("Audio disable error:", e);
            }
        } else {
            // Enable audio
            try {
                state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: { autoGainControl: false, echoCancellation: false, noiseSuppression: false }
                });
                const src = state.audioContext.createMediaStreamSource(stream);
                state.gainNode = state.audioContext.createGain();
                state.gainNode.gain.value = (els.volSlider.value / 100) * els.dspSlider.value;
                state.audioAnalyser = state.audioContext.createAnalyser();
                state.audioAnalyser.fftSize = 256;
                src.connect(state.gainNode);
                state.gainNode.connect(state.audioAnalyser);
                state.gainNode.connect(state.audioContext.destination);
                els.btnAudio.innerText = "Disable Audio";
                els.btnAudio.classList.add('active-toggle');
                els.volSlider.disabled = false;
				els.dspSlider.disabled = false;
                els.lblStatus.innerText = "Audio Active";
                drawAudio();
            } catch (e) {
                alert("Audio Error: " + e.message);
            }
        }
    });

   // Function to calculate total gain
function updateAudioGain() {
    if (state.gainNode) {
        const vol = els.volSlider.value / 100; // 0.0 to 5.0
        const dsp = els.dspSlider.value;       // 1 to 20
        state.gainNode.gain.value = vol * dsp;
    }
}

els.volSlider.addEventListener('input', updateAudioGain);

els.dspSlider.addEventListener('input', (e) => {
    updateAudioGain();
    // Optional: Visual feedback on tooltip or label could go here
});

  function drawAudio() {
        // If audio is off, clear canvas and return
        if (!state.audioAnalyser || !state.audioContext || state.audioContext.state === 'closed') {
            const cvs = els.audio;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = '#161b22';
            ctx.fillRect(0, 0, cvs.width, cvs.height);
            return;
        }

        const cvs = els.audio;
        const ctx = cvs.getContext('2d');
        const w = cvs.width;
        const h = cvs.height;
        const data = new Uint8Array(state.audioAnalyser.frequencyBinCount);
        state.audioAnalyser.getByteTimeDomainData(data);

        ctx.fillStyle = '#161b22';
        ctx.fillRect(0, 0, w, h);
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#2f81f7';
        ctx.beginPath();
        const slice = w * 1.0 / data.length;
        let x = 0;
        for (let i = 0; i < data.length; i++) {
            const v = data[i] / 128.0;
            const y = v * h / 2;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
            x += slice;
        }
        ctx.stroke();
    }

    // Initialize
    updateBandLimits();
    
    // Set initial dwell label color (5ms = yellow/moderate)
    els.dwellLabel.style.color = '#d29922';
    
	// --- HIGH PERFORMANCE RENDER LOOP ---
    // This runs at 60fps (or screen refresh rate) independently of the scanner



// --- INITIALIZATION ---
    // Force canvas sizing immediately
    function resizeCanvases() {
        const container = document.querySelector('.viz-container');
        if (container && container.clientWidth > 0) {
            const w = container.clientWidth;
            els.spectrum.width = w;
            els.spectrum.height = 80;
            els.waterfall.width = w;
            // Use clientHeight if available and reasonable, otherwise fixed 150
            const wfHeight = els.waterfall.clientHeight;
            els.waterfall.height = (wfHeight > 50) ? wfHeight : 150;
            els.audio.width = w;
            els.audio.height = 35;
        }
    }

    // Listen for resize
    new ResizeObserver(resizeCanvases).observe(document.querySelector('.viz-container'));
    
    // Run once on load
    resizeCanvases();
    
    // DEBUG: Test waterfall canvas visibility
    setTimeout(() => {
        console.log('Waterfall canvas:', els.waterfall.width, 'x', els.waterfall.height);
        const ctx = els.waterfall.getContext('2d');
        // Draw a test gradient to verify canvas is visible
        for (let y = 0; y < 50; y++) {
            ctx.fillStyle = `hsl(${y * 7}, 100%, 50%)`;
            ctx.fillRect(0, y, els.waterfall.width, 1);
        }
    }, 500);
    
    // Initialize Tuning Knob
    initTuningKnob();

    // START THE ENGINE
    requestAnimationFrame(animationLoop);
























  // --- MAIN ANIMATION LOOP ---
    function animationLoop() {
        // 1. Always Draw Spectrum (keeps grid visible)
        drawSpectrum();
        // Note: Waterfall is drawn from scanLoop when new data arrives
        // 2. Always Draw Audio (if active)
        drawAudio();

        // 3. Keep looping
        requestAnimationFrame(animationLoop);
    }
    
   
	
initTuningKnob();
</script>
</body>
</html>
